import random
from typing import Any, Callable, Dict, List, Optional, Tuple, Union

import pandas as pd

from code_genie._cache import _CacheManager, _CacheValue
from code_genie.client import Client, GetExecutableRequest


class Genie:
    _hash_sep = "::"

    def __init__(
        self,
        inputs: Optional[Dict[str, Any]] = None,
        allowed_imports: Optional[List[str]] = None,
        client: Optional[Client] = None,
        cache_dir: Optional[str] = None,
    ):
        """Initialize a genie instance

        Args:
            inputs: a dictionary of inputs to the function. the keys are the names of the inputs and the values are
                small description of the inputs.
            allowed_imports: a list of imports which are allowed to be used in the code. note that this is not
                strictly enforced yet, but simplpy passed to the GPT API in the prompt.
            client: an instance of the client to use for making requests to the api. if not provided, a new instance
                will be created.
            cache_dir: if provided, the code generated by the genie will be cached in this directory. if not
                provided, the global default is used. it is recommended to use set_cache_dir() method to set this.

        Returns:
            A callable which can be used to execute the code generated by the genie.
        """
        self._inputs = inputs
        self._allowed_imports = allowed_imports
        self._cache = _CacheManager(cache_dir)
        self._client = client or Client()

        # cache last run id
        self._latest_run_id = None
        self._latest_callable = None
        self._latest_code = None

    def plz(
        self,
        instructions: Optional[Union[str, List[str]]],
        additional_inputs: Optional[Dict[str, Any]] = None,
        override: bool = False,
    ):
        """Generate code for a new task

        Args:
            instructions: text instructions on the task required to be performed. use the keywords in inputs argument
                to refer to the inputs.
            additional_inputs: a dictionary of inputs to the function. the keys are the names of the inputs and the values are
                small description of the inputs.
            override: if a genie has been generated before with the same args, then it will be loaded from cache be
                default. set override to True to make a new API call and recreate the genie.

        Returns:
            A callable which can be used to execute the code generated by the genie.
        """
        if isinstance(instructions, str):
            instructions = [instructions]

        # check cache
        cache_key = self._get_hash_str(instructions, additional_inputs)
        cache_value = self._cache.get(cache_key)

        # case: reading from cache
        if (not override) and (cache_value is not None):
            code, fn_name, id = cache_value.code, cache_value.fn_name, cache_value.id
            print(f"Loading cached genie id: {cache_value.id}, set override = True to rerun")
        # case: creating new genie
        else:
            code, fn_name = self._get_code(instructions, additional_inputs)
            id = self._generate_id(fn_name)
            self._cache.update(cache_key, _CacheValue(code=code, fn_name=fn_name, id=id))
            print(f"Genie cached with id: {id}")

        # create executor and return results
        executor = self._extract_executable(code, fn_name)
        self._latest_run_id = id
        self._latest_code = code
        self._latest_callable = executor
        return executor(**(self._combine_inputs(additional_inputs)))

    def _combine_inputs(self, additional_inputs: Optional[Dict[str, Any]]) -> Dict[str, Any]:
        return {**(self._inputs or {}), **(additional_inputs or {})}

    @staticmethod
    def _create_input_str(x):
        if isinstance(x, pd.DataFrame):
            return f"pandas dataframes with columns: {x.columns}"
        return f"{type(x)}"

    def _get_code(self, instructions: List[str], additional_inputs: Dict[str, Any]) -> Tuple[str, str]:
        input_str = {
            key: self._create_input_str(value) for key, value in self._combine_inputs(additional_inputs).items()
        }
        return self._client.get_generic(
            GetExecutableRequest(instructions=instructions, inputs=input_str, allowed_imports=self._allowed_imports)
        )

    @classmethod
    def _extract_executable(cls, code: str, fn_name: str) -> Callable:
        # define function in memory
        mem = {}
        exec(code, mem)
        return mem[fn_name]

    @classmethod
    def _generate_id(cls, fn_name: str) -> str:
        # use fn name with random 5 digit suffix
        return f"{fn_name}_{random.randint(10000, 99999)}"

    @classmethod
    def _list_to_str(cls, l: List[str]) -> str:
        return cls._hash_sep.join(l)

    @classmethod
    def _inputs_to_str(cls, d: Dict[str, Any]) -> str:
        return cls._hash_sep.join([f"{k}={type(v)}" for k, v in d.items()])

    def _get_hash_str(self, instructions: List[str], additional_inputs: Optional[Dict[str, Any]]) -> str:
        hash_strings = [
            self._list_to_str(instructions),
            self._inputs_to_str(self._inputs or {}),
            self._list_to_str(self._allowed_imports or {}),
            self._inputs_to_str(additional_inputs or {}),
        ]
        return self._hash_sep.join(hash_strings)

    @property
    def last_run_id(self) -> str:
        return self._latest_run_id

    @property
    def latest_callable(self) -> Callable:
        return self._latest_callable

    def read_cache(self):
        return self._cache.get_all_code_segments()
