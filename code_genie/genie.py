import random
from typing import Any, Callable, Dict, List, Optional, Tuple, Union

import pandas as pd
from pydantic import BaseModel

from code_genie._cache import _CacheManager, _CacheValue
from code_genie.client import Client


class GenieResult(BaseModel):
    id: str
    code: str
    cache_dir: str
    result: Any = None


class Genie:
    _hash_sep = "::"

    def __init__(
        self,
        inputs: Optional[Dict[str, Any]] = None,
        client: Optional[Client] = None,
        cache_dir: Optional[str] = None,
    ):
        """Initialize a genie instance

        Args:
            inputs: a dictionary of inputs to the function. the keys are the names of the inputs and the values are
                small description of the inputs.
            client: an instance of the client to use for making requests to the api. if not provided, a new instance
                will be created.
            cache_dir: if provided, the code generated by the genie will be cached in this directory. if not
                provided, the global default is used. it is recommended to use set_cache_dir() method to set this.

        Returns:
            A callable which can be used to execute the code generated by the genie.
        """
        self._inputs = inputs
        self._cache = _CacheManager(cache_dir)
        self._client = client or Client()

        # cache last run id
        self._latest_run_id = None
        self._latest_callable = None
        self._latest_code = None

    def plz(
        self,
        instructions: Optional[Union[str, List[str]]],
        additional_inputs: Optional[Dict[str, Any]] = None,
        override: bool = False,
    ):
        """Generate code for a new task

        Args:
            instructions: text instructions on the task required to be performed. use the keywords in inputs argument
                to refer to the inputs.
            additional_inputs: a dictionary of inputs to the function. the keys are the names of the inputs and the values are
                small description of the inputs.
            override: if a genie has been generated before with the same args, then it will be loaded from cache be
                default. set override to True to make a new API call and recreate the genie.

        Returns:
            A callable which can be used to execute the code generated by the genie.
        """
        if isinstance(instructions, str):
            instructions = [instructions]

        # check cache
        cache_key = self._get_hash_str(instructions, additional_inputs)
        cache_value = self._cache.get(cache_key)

        # case: reading from cache
        if (not override) and (cache_value is not None):
            code, fn_name, id = cache_value.code, cache_value.fn_name, cache_value.id
            print(f"Loading cached genie id: {cache_value.id}, set override = True to rerun")
        # case: creating new genie
        else:
            inputs = self._combine_inputs(additional_inputs)
            code, fn_name = self._get_code(instructions, inputs)
            id = self._generate_id(fn_name)
            self._cache.update(cache_key, _CacheValue(code=code, fn_name=fn_name, id=id, instructions=instructions,
                                                      inputs=list(inputs.keys())))
            print(f"Genie cached with id: {id}")

        # create executor and return results
        executor = self._extract_executable(code, fn_name)
        self._latest_run_id = id
        self._latest_code = code
        self._latest_callable = executor
        return executor(**(self._combine_inputs(additional_inputs)))

    def _combine_inputs(self, additional_inputs: Optional[Dict[str, Any]]) -> Dict[str, Any]:
        return {**(self._inputs or {}), **(additional_inputs or {})}

    @staticmethod
    def _create_input_str(x):
        if isinstance(x, pd.DataFrame):
            return f"pandas dataframes with columns: {x.columns}"
        return f"{type(x)}"

    def _get_code(self, instructions: List[str], inputs: Dict[str, Any]) -> Tuple[str, str]:
        input_str = {
            key: self._create_input_str(value) for key, value in inputs.items()
        }
        return self._client.get(instructions=instructions, inputs=input_str)

    @classmethod
    def _extract_executable(cls, code: str, fn_name: str) -> Callable:
        # define function in memory
        mem = {}
        exec(code, mem)
        return mem[fn_name]

    @classmethod
    def _generate_id(cls, fn_name: str) -> str:
        # use fn name with random 5 digit suffix
        return f"{fn_name}_{random.randint(10000, 99999)}"

    @classmethod
    def _list_to_str(cls, l: List[str]) -> str:
        return cls._hash_sep.join(l)

    @classmethod
    def _inputs_to_str(cls, d: Dict[str, Any]) -> str:
        return cls._hash_sep.join([f"{k}={type(v)}" for k, v in d.items()])

    def _get_hash_str(self, instructions: List[str], additional_inputs: Optional[Dict[str, Any]]) -> str:
        hash_strings = [
            self._list_to_str(instructions),
            self._inputs_to_str(self._inputs or {}),
            self._inputs_to_str(additional_inputs or {}),
        ]
        return self._hash_sep.join(hash_strings)

    @property
    def last_run_id(self) -> str:
        return self._latest_run_id

    @property
    def latest_callable(self) -> Callable:
        return self._latest_callable

    def read_cache(self):
        return self._cache.get_all_code_segments()
